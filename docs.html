<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Hidden Markov Model Explained Visually - Will Paul</title>
    <meta name="description" content="Hidden Markov Model Explained Visually - Will Paul">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <link href='http://fonts.googleapis.com/css?family=Merriweather:400,900italic,900,700italic,700,400italic,300italic,300&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div class="content">
      <h1>Observable Markov Models Explained Visually</h1>
      <h3>by Will Paul <a href="index.html">Project</a></h3>

      <h2>Intro</h2>

      <h2>Design &amp; technical motivations</h2>

      <h2>Project requirements</h2>

      <h2>Why its cool</h2>

      <h2>Issues &amp; future work</h2>

      <h2>References</h2>

      <h3>Content</h3>

      <p>Most of what I know about Markov processes is from Jurafsky and Martin's NLP textbook:</p>

      <p>Daniel Jurafsky and James H. Martin. 2000. <em>Speech and Language Processing: An Introduction to Natural Language Processing</em>, Computational Linguistics, and Speech Recognition (1st ed.). Prentice Hall PTR, Upper Saddle River, NJ, USA.</p>

      <h3>Libraries</h3>

      <ul>
        <li>
          <em><a href="http://github.com/mbostock/d3"><strong>D3.js</strong></a>, "D3.js is a JavaScript library for manipulating documents based on data."</em>

          <ul>
            <li>Implements the math/physics for the force layout, but none of the rendering.</li>
            <li>Some convenience methods for manipulating data (e.g. color and linear scales)</li>
            <li>Light abstraction around events (e.g. combining touch and click events)</li>
          </ul>
        </li>
        <li>
          <em><a href="https://lodash.com/"><strong>Lodash.js</strong></a>, "A JavaScript utility library delivering consistency, modularity, performance, &amp; extras."</em>

          <ul>
            <li>Used wherever you see the `_` function, fixes problems with JavaScripts collection methods. I primarily use it to make array/object methods chainable and to take a little more functional approach to writing loops.</li>
          </ul>
        </li>
      </ul>

      <h3>Borrowed code/ideas</h3>

      <p>The Point object is modeled after Processing's PVector and Paper's Point.</p>

      <p>The arrows at the tips of the quadratic curves used <a href="http://bit.ly/1IIDTDa">this guy on Stackoverflow's math.</a></p>

      <p>Animating on Bezier curves (quadratic and cubic) uses <a href="http://en.wikipedia.org/wiki/De_Casteljau's_algorithm">De Casteljau's algorithm</a>, <a href="http://bit.ly/1GHKvTe">as proposed by this guy on Stackoverflow.</a></p>


      <p><a href="http://www.informit.com/articles/article.aspx?p=1834699&amp;seqNum=4">This code lets you have variable length argument lists:</a></p>

      <pre><code>
      vals = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];

      // Somewhere later...
      app.some_function.apply(some_scope, vals);
      </code></pre>

      <p>Using `void 0` instead of `undefined` is a safer since it is a statement (that <em>always</em> returns undefined) and thus cannot be overwritten (undefined can). <a href="http://stackoverflow.com/questions/7452341/what-does-void-0-mean">Discussion here</a></p>

      <p><a href="http://stackoverflow.com/questions/8035822/why-write-callthis-at-the-end-of-an-javascript-anonyms-function">Scope management for your IFFEs:</a></p>

      <pre><code>
      // IFFE with:
      (function() {}).call(this)
      // Instead of
      (function() {})()
      </code></pre>


      <pre><code>
      </code></pre>

    </div>

    <!--   <h2>Introduction</h2> -->
    <!--  -->
    <!--   <p>Hidden Markov Models (or HMMs) are kind of scary by default, who's Markov, what's hidden, and why do I care? To make matters worse most textbooks start with a technical definition like:</p> -->
    <!--  -->
    <!--   <table> -->
    <!--     <tr> -->
    <!--       <td> -->
    <!--         $$ Q = q_{1}q_{2}...q_{N} $$ -->
    <!--       </td> -->
    <!--  -->
    <!--       <td> -->
    <!--         a set of N states -->
    <!--       </td> -->
    <!--     </tr> -->
    <!--  -->
    <!--     <tr> -->
    <!--       <td> -->
    <!--         $$ A = a_{11}a_{12}...a_{n1}..a_{nn} $$ -->
    <!--       </td> -->
    <!--  -->
    <!--       <td> -->
    <!--         a transition probability matrix -->
    <!--       </td> -->
    <!--     </tr> -->
    <!--  -->
    <!--     <tr> -->
    <!--       <td> -->
    <!--         $$ O = o_{1}o_{2}...o_{T} $$ -->
    <!--       </td> -->
    <!--  -->
    <!--       <td> -->
    <!--         A sequence of T observations, from a vocabulary $$ V = v_1,v_2,...v_v $$ -->
    <!--       </td> -->
    <!--     </tr> -->
    <!--  -->
    <!--     <tr> -->
    <!--       <td> -->
    <!--         $$ B = b_{i}(o_{t}) $$ -->
    <!--       </td> -->
    <!--  -->
    <!--       <td> -->
    <!--         A sequence of observation likelihoods. -->
    <!--       </td> -->
    <!--     </tr> -->
    <!--  -->
    <!--     <tr> -->
    <!--       <td> -->
    <!--         $$ q_{0},q_{F} $$ -->
    <!--       </td> -->
    <!--  -->
    <!--       <td> -->
    <!--         A start state and final state. -->
    <!--       </td> -->
    <!--     </tr> -->
    <!--   </table> -->
    <!--  -->
    <!--   <p>And only moments later jump into dynamic programming and efficient methods of solving them. There is nothing wrong with efficient algorithms or mathematical formalism, but before any of that will make sense the problem should be motivated and simple examples given to build intuition for what is actually going on.</p> -->
    <!--  -->
    <!--   <h2>Technical Approach</h2> -->
    <!--  -->
    <!--   <h3>Library Dependencies</h3> -->
    <!--  -->
    <!--   <ul> -->
    <!--     <li>D3.js, for the physics in the force layout</li> -->
    <!--     <li>Lodash.js for common functional programming paradigms</li> -->
    <!--     <li>(Probably) Mathjax for typesetting math stuff as necessary</li> -->
    <!--   </ul> -->
    <!--  -->
    <!--   <h2>Topics and Source Material</h2> -->
    <!--  -->
    <!--   <p>Most of the material and knowledge I put forward here will be from Natural Language Processing textbook, and sources cited within. I will be sure to cite sources in the visualization as well.</p> -->
    <!--  -->
    <!--   <h3>Knowledge Dependencies</h3> -->
    <!--  -->
    <!--   <p>I want to limit the dependencies as much as possible so that just about anyone can walk through the experience and take at least <em>something</em> of value away from it.</p> -->
    <!--  -->
    <!--   <p>That said I'm not going to have space to define every concept necessary, so I'll be offloading several key concepts off to others as necessary, whenever possible using a visual explanation that follows in kind</p> -->
    <!--  -->
    <!--   <ul> -->
    <!--     <li> -->
    <!--       Probability concepts, especially conditional probability is going to be pretty fundamental to any discussion of models. Luckily someone else put together an excellent conditional probability visualization that should develop enough intuition for anyone to move through this material. -->
    <!--     </li> -->
    <!--   </ul> -->
    <!--  -->
    <!--   <h3>Learn Along the Way</h3> -->
    <!--  -->
    <!--   <ul> -->
    <!--     <li>Finite State Automata</li> -->
    <!--     <li>Markov Chains</li> -->
    <!--     <li>(Maybe, if it proves useful) FSA Transducers</li> -->
    <!--   </ul> -->
    <!--  -->
    <!--   <h3>End Goals</h3> -->
    <!--  -->
    <!--   <p>The end goal for a user of this project is that they be able to understand the underlying problems that an HMM can be used to solve and at a high level how these get solved (e.g. what the algorithm does generally). This should put a user in a good position to dive into a technical textbook and begin implementing the solutions for themselves.</p> -->
    <!--  -->
    <!--   <h4>Problem 1: Likelihood, calculated with the Forward Algorithm</h4> -->
    <!--  -->
    <!--   <p>Given an HMM $$ \lambda = (A,B) $$<br/> -->
    <!--   And an observation sequence <em>O</em><br/> -->
    <!--   Determine the likelihood of $$ P(O|\lambda) $$</p> -->
    <!--  -->
    <!--   $$ \therefore $$ -->
    <!--   $$ \lambda(A,B) \land O \rightarrow P(O|\lambda) $$ -->
    <!--  -->
    <!--   <p>In other words what is the probability of a given observation sequence</p> -->
    <!--  -->
    <!--  -->
    <!--   <h4>Problem 2: Decoding, calculated with the Viterbi Algorithm</h4> -->
    <!--  -->
    <!--   <p>Given an observation sequence <em>O</em><br /> -->
    <!--   And an HMM $$ \lambda = (A,B) $$ <br /> -->
    <!--   Discover the best hidden state sequence Q</p> -->
    <!--  -->
    <!--   $$ \therefore $$ -->
    <!--   $$ \lambda(A,B) \land O \rightarrow Q $$ -->
    <!--  -->
    <!--  -->
    <!--   <h4>Problem 3: Learning: calculate with the Forward&#45;Backward Algorithm</h4> -->
    <!--  -->
    <!--   <p>Given an observation sequence O<br/> -->
    <!--   And the set of states in the HMM <br/> -->
    <!--   Learn the HMM parameters A and B </p> -->
    <!--  -->
    <!--   $$ \therefore $$ -->
    <!--   $$ O \land Q \rightarrow \lambda(A,B) $$ -->
    <!--  -->
    <!-- </div> -->

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
  </body>
</html>

